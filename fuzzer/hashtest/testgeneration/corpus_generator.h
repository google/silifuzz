// Copyright 2026 The Silifuzz Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef THIRD_PARTY_SILIFUZZ_FUZZER_HASHTEST_TESTGENERATION_CORPUS_GENERATOR_H_
#define THIRD_PARTY_SILIFUZZ_FUZZER_HASHTEST_TESTGENERATION_CORPUS_GENERATOR_H_

#include <cstddef>

#include "absl/functional/any_invocable.h"
#include "./fuzzer/hashtest/parallel_worker_pool.h"
#include "./fuzzer/hashtest/runnable_corpus.h"
#include "./fuzzer/hashtest/testgeneration/candidate.h"
#include "./fuzzer/hashtest/testgeneration/instruction_pool.h"
#include "./instruction/xed_util.h"

namespace silifuzz {

// Information about the criteria for generating the corpus.
struct GenerationConfig {
  // Number of inputs for each test.
  size_t num_inputs = 0;

  // Number of tests to generate for the corpus.
  size_t num_tests = 0;

  // How often should flags generated by an instruction be captured?
  // Capturing flag has a runtime and code size cost.
  // 0 means flags are never captured, 1 means they are always captured.
  float flag_capture_rate = 0.5f;
  // When flags are captured, should the trap bit be masked?
  // This prevents a test from producing different results when it is being
  // traced. If the test process may be traced or debugged, set this to true.
  bool mask_trap_flag = true;

  // How many additional steps can be added to the test when adding branches?
  // For example, if a branch is added around two steps in the test schedule,
  // the two test steps become four steps - two on each side of the branch. In
  // all cases the same number of test steps will be executed every test
  // iteration, but the size of the test executable will increased as steps are
  // duplicated. A value of 0.5 means the test size will be ~50% larger than if
  // there were no branches. A value of 0.0 means that no branches will be added
  // to the test.
  float min_duplication_rate = 0.0f;
  float max_duplication_rate = 0.5f;
  // How many bits of entropy should be tested when branching?
  // 1 means there's an equal chance to take either side of the branch.
  // 2 means one side of the branch with be taken 75% of the time, and the
  // other 25%.
  // Increasing this value increases the predictability of branches, which can
  // increase the number of tests run a second. On the other hand, increasing
  // this number too much means one side of the branch is effectively never
  // taken. Different SDCs can respond differently to this parameter - some like
  // branch misses (or slower execution?) but most seem to like the throughput
  // that comes from semi-predictable branches.
  int branch_test_bits = 3;

  // The chip to generate the corpus for.
  xed_chip_enum_t chip = XED_CHIP_INVALID;

  // The seed used to generate this corpus.  For the same major & minor
  // version of HashTest, the same seed will generate the same
  // RunnableCorpus (See README.md for more information)
  size_t seed = 0;
};

// Class responsible for generating corpuses.
//
// A class is used here so that the InstructionPool does not need to be rebuilt
// for each corpus, which could be an expensive operation.
class CorpusGenerator {
 public:
  CorpusGenerator() = default;

  // Generates a corpus for the provided configuration.  Applies the
  // instruction_filter to the InstructionPool prior to corpus generation.
  // Performs the generation across all of the treads in the provided thread
  // pool.
  RunnableCorpus GenerateCorpusForConfig(
      const GenerationConfig& config,
      std::function<bool(const InstructionCandidate&)> instruction_filter,
      ParallelWorkerPool& workers);

 private:
  std::vector<Input> GenerateInputs(size_t num_inputs);
  RunnableCorpus AllocateCorpus(size_t num_tests);
  InstructionPool ipool_;
  xed_chip_enum_t chip_for_ipool_;
  std::mt19937_64 rng_;
};

}  // namespace silifuzz

#endif  // THIRD_PARTY_SILIFUZZ_FUZZER_HASHTEST_TESTGENERATION_CORPUS_GENERATOR_H_
