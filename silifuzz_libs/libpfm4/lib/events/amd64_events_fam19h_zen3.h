/*
 * Contributed by Swarup Sahoo
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * This file is part of libpfm, a performance monitoring support library for
 * applications on Linux.
 *
 * PMU: amd64_fam19h_zen3 (AMD64 Fam19h Zen3)
 */

static const amd64_umask_t amd64_fam19h_zen3_retired_sse_avx_flops[]={
  { .uname  = "ADD_SUB_FLOPS",
    .udesc  = "Addition/subtraction FLOPS",
    .ucode  = 0x1,
  },
  { .uname  = "MULT_FLOPS",
    .udesc  = "Multiplication FLOPS",
    .ucode  = 0x2,
  },
  { .uname  = "DIV_FLOPS",
    .udesc  = "Division/Square-root FLOPS",
    .ucode  = 0x4,
  },
  { .uname  = "MAC_FLOPS",
    .udesc  = "Multiply-Accumulate flops. Each MAC operation is counted as 2 FLOPS",
    .ucode  = 0x8,
  },
  { .uname  = "ANY",
    .udesc  = "Double precision add/subtract flops",
    .ucode  = 0xf,
    .uflags = AMD64_FL_DFL | AMD64_FL_NCOMBO,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_retired_serializing_ops[]={
  { .uname  = "X87_CTRL_RET",
    .udesc  = "x87 control word mispredict traps due to mispredction in RC or PC, or changes in Exception Mask bits",
    .ucode  = 0x1,
  },
  { .uname  = "X87_BOT_RET",
    .udesc  = "x87 bottom-executing ops retired",
    .ucode  = 0x2,
  },
  { .uname  = "SSE_CTRL_RET",
    .udesc  = "SSE/AVX control word mispredict traps",
    .ucode  = 0x4,
  },
  { .uname  = "SSE_BOT_RET",
    .udesc  = "SSE/AVX bottom-executing ops retired",
    .ucode  = 0x8,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_fp_dispatch_faults[]={
  { .uname  = "X87_FILL_FAULT",
    .udesc  = "x87 fill faults",
    .ucode  = 0x1,
  },
  { .uname  = "XMM_FILL_FAULT",
    .udesc  = "XMM fill faults",
    .ucode  = 0x2,
  },
  { .uname  = "YMM_FILL_FAULT",
    .udesc  = "YMM fill faults",
    .ucode  = 0x4,
  },
  { .uname  = "YMM_SPILL_FAULT",
    .udesc  = "YMM spill faults",
    .ucode  = 0x8,
  },
  { .uname  = "ANY",
    .udesc  = "Any FP dispatch faults",
    .ucode  = 0xf,
    .uflags = AMD64_FL_DFL | AMD64_FL_NCOMBO,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_bad_status_2[]={
  { .uname  = "STLI_OTHER",
    .udesc  = "Store-to-load conflicts. A load was unable to complete due to a non-forwardable conflict with an older store",
    .ucode  = 0x2,
    .uflags = AMD64_FL_DFL,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_retired_lock_instructions[]={
  { .uname  = "BUS_LOCK",
    .udesc  = "Number of bus locks",
    .ucode  = 0x1,
    .uflags = AMD64_FL_DFL,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_ls_dispatch[]={
  { .uname  = "LD_ST_DISPATCH",
    .udesc  = "Dispatched op that performs a load from and store to the same memory address",
    .ucode  = 0x4,
  },
  { .uname  = "STORE_DISPATCH",
    .udesc  = "Store ops dispatched",
    .ucode  = 0x2,
  },
  { .uname  = "LD_DISPATCH",
    .udesc  = "Load ops dispatched",
    .ucode  = 0x1,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_store_commit_cancels_2[]={
  { .uname  = "WCB_FULL",
    .udesc  = "Non cacheable store and the non-cacheable commit buffer is full",
    .ucode  = 0x1,
    .uflags = AMD64_FL_DFL,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_mab_allocation_by_type[]={
  { .uname  = "LS",
    .udesc  = "Load store allocations",
    .ucode  = 0x3f,
    .uflags = AMD64_FL_NCOMBO,
  },
  { .uname  = "HW_PF",
    .udesc  = "Hardware prefetcher allocations",
    .ucode  = 0x40,
    .uflags = AMD64_FL_NCOMBO,
  },
  { .uname  = "ALL",
    .udesc  = "All allocations",
    .ucode  = 0x7f,
    .uflags = AMD64_FL_NCOMBO,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_software_prefetch_data_cache_fills[]={
  { .uname  = "LCL_L2",
    .udesc  = "Fill from local L2 to the core",
    .ucode  = 0x1,
  },
  { .uname  = "INT_CACHE",
    .udesc  = "Fill from L3 or different L2 in same CCX",
    .ucode  = 0x2,
  },
  { .uname  = "EXT_CACHE_LCL",
    .udesc  = "Fill from cache of different CCX in same node",
    .ucode  = 0x4,
  },
  { .uname  = "MEM_IO_LCL",
    .udesc  = "Fill from DRAM or IO connected in same node",
    .ucode  = 0x8,
  },
  { .uname  = "EXT_CACHE_RMT",
    .udesc  = "Fill from CCX cache in different node",
    .ucode  = 0x10,
  },
  { .uname  = "MEM_IO_RMT",
    .udesc  = "Fill from DRAM or IO connected in different node",
    .ucode  = 0x40,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_l1_dtlb_miss[]={
  { .uname  = "TLB_RELOAD_1G_L2_MISS",
    .udesc  = "Data TLB reload to a 1GB page that missed in the L2 TLB",
    .ucode  = 0x80,
  },
  { .uname  = "TLB_RELOAD_2M_L2_MISS",
    .udesc  = "Data TLB reload to a 2MB page that missed in the L2 TLB",
    .ucode  = 0x40,
  },
  { .uname  = "TLB_RELOAD_COALESCED_PAGE_MISS",
    .udesc  = "Data TLB reload to a coalesced page that also missed in the L2 TLB",
    .ucode  = 0x20,
  },
  { .uname  = "TLB_RELOAD_4K_L2_MISS",
    .udesc  = "Data TLB reload to a 4KB page that missed in the L2 TLB",
    .ucode  = 0x10,
  },
  { .uname  = "TLB_RELOAD_1G_L2_HIT",
    .udesc  = "Data TLB reload to a 1GB page that hit in the L2 TLB",
    .ucode  = 0x8,
  },
  { .uname  = "TLB_RELOAD_2M_L2_HIT",
    .udesc  = "Data TLB reload to a 2MB page that hit in the L2 TLB",
    .ucode  = 0x4,
  },
  { .uname  = "TLB_RELOAD_COALESCED_PAGE_HIT",
    .udesc  = "Data TLB reload to a coalesced page that hit in the L2 TLB",
    .ucode  = 0x2,
  },
  { .uname  = "TLB_RELOAD_4K_L2_HIT",
    .udesc  = "Data TLB reload to a 4KB page that hit in the L2 TLB",
    .ucode  = 0x1,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_misaligned_loads[]={
  { .uname  = "MA4K",
    .udesc  = "The number of 4KB misaligned (page crossing) loads",
    .ucode  = 0x2,
  },
  { .uname  = "MA64",
    .udesc  = "The number of 64B misaligned (cacheline crossing) loads",
    .ucode  = 0x1,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_prefetch_instructions_dispatched[]={
  { .uname  = "PREFETCH_T0_T1_T2",
    .udesc  = "Number of prefetcht0, perfetcht1, prefetcht2 instructions dispatched",
    .ucode  = 0x1,
  },
  { .uname  = "PREFETCHW",
    .udesc  = "Number of prefetchtw instructions dispatched",
    .ucode  = 0x2,
  },
  { .uname  = "PREFETCHNTA",
    .udesc  = "Number of prefetchtnta instructions dispatched",
    .ucode  = 0x4,
  },
  { .uname  = "ANY",
    .udesc  = "Any prefetch",
    .ucode  = 0x7,
    .uflags = AMD64_FL_DFL | AMD64_FL_NCOMBO,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_ineffective_software_prefetch[]={
  { .uname  = "MAB_MCH_CNT",
    .udesc  = "Software prefetch instructions saw a match on an already allocated miss request buffer",
    .ucode  = 0x2,
  },
  { .uname  = "DATA_PIPE_SW_PF_DC_HIT",
    .udesc  = "Software Prefetch instruction saw a DC hit",
    .ucode  = 0x1,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_tlb_flushes[]={
  { .uname  = "ALL",
    .udesc  = "Any TLB flush",
    .ucode  = 0xff,
    .uflags = AMD64_FL_DFL,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_l1_itlb_miss_l2_itlb_miss[]={
  { .uname  = "COALESCED4K",
    .udesc  = "Number of instruction fetches to a >4K coalesced page",
    .ucode  = 0x8,
  },
  { .uname  = "IF1G",
    .udesc  = "Number of instruction fetches to a 1GB page",
    .ucode  = 0x4,
  },
  { .uname  = "IF2M",
    .udesc  = "Number of instruction fetches to a 2MB page",
    .ucode  = 0x2,
  },
  { .uname  = "IF4K",
    .udesc  = "Number of instruction fetches to a 4KB page",
    .ucode  = 0x1,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_itlb_fetch_hit[]={
  { .uname  = "IF1G",
    .udesc  = "L1 instruction fetch TLB hit a 1GB page size",
    .ucode  = 0x4,
  },
  { .uname  = "IF2M",
    .udesc  = "L1 instruction fetch TLB hit a 2MB page size",
    .ucode  = 0x2,
  },
  { .uname  = "IF4K",
    .udesc  = "L1 instruction fetch TLB hit a 4KB or 16KB page size",
    .ucode  = 0x1,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_ic_tag_hit_miss[]={
  { .uname  = "IC_HIT",
    .udesc  = "Instruction cache hit",
    .ucode  = 0x7,
    .uflags = AMD64_FL_NCOMBO,
  },
  { .uname  = "IC_MISS",
    .udesc  = "Instruction cache miss",
    .ucode  = 0x18,
    .uflags = AMD64_FL_NCOMBO,
  },
  { .uname  = "ALL_IC_ACCESS",
    .udesc  = "All instruction cache accesses",
    .ucode  = 0x1f,
    .uflags = AMD64_FL_NCOMBO,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_op_cache_hit_miss[]={
  { .uname  = "OC_HIT",
    .udesc  = "Op cache hit",
    .ucode  = 0x3,
    .uflags = AMD64_FL_NCOMBO,
  },
  { .uname  = "OC_MISS",
    .udesc  = "Op cache miss",
    .ucode  = 0x4,
    .uflags = AMD64_FL_NCOMBO,
  },
  { .uname  = "ALL_OC_ACCESS",
    .udesc  = "All op cache accesses",
    .ucode  = 0x7,
    .uflags = AMD64_FL_NCOMBO,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_ops_source_dispatched_from_decoder[]={
  { .uname  = "X86DECODER_DISPATCHED",
    .udesc  = "Number of ops fetched from Instruction Cache and dispatched",
    .ucode  = 0x1,
  },
  { .uname  = "OPCACHE_DISPATCHED",
    .udesc  = "Number of ops fetched from Op Cache and dispatched",
    .ucode  = 0x2,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_ops_type_dispatched_from_decoder[]={
  { .uname  = "FP_DISP_IBS_MODE",
    .udesc  = "Any FP dispatch. Count aligns with IBS count",
    .ucode  = 0x04,
    .uflags = AMD64_FL_NCOMBO,
  },
  { .uname  = "INT_DISP_IBS_MODE",
    .udesc  = "Any Integer dispatch. Count aligns with IBS count",
    .ucode  = 0x08,
    .uflags = AMD64_FL_NCOMBO,
  },
  { .uname  = "FP_DISP_RETIRE_MODE",
    .udesc  = "Any FP dispatch. Count aligns with RETIRED_OPS count",
    .ucode  = 0x84,
    .uflags = AMD64_FL_NCOMBO,
  },
  { .uname  = "INT_DISP_RETIRE_MODE",
    .udesc  = "Any Integer dispatch. Count aligns with RETIRED_OPS count",
    .ucode  = 0x88,
    .uflags = AMD64_FL_NCOMBO,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_dispatch_resource_stall_cycles_1[]={
  { .uname  = "INT_PHY_REG_FILE_RSRC_STALL",
    .udesc  = "Number of cycles stalled due to integer physical register file resource stalls. Applies to all ops that have integer destination register",
    .ucode  = 0x1,
  },
  { .uname  = "LOAD_QUEUE_RSRC_STALL",
    .udesc  = "Number of cycles stalled due to load queue resource stalls. Applies to all ops with load semantics",
    .ucode  = 0x2,
  },
  { .uname  = "STORE_QUEUE_RSRC_STALL",
    .udesc  = "Number of cycles stalled due to store queue resource stalls. Applies to all ops with store semantics",
    .ucode  = 0x4,
  },
  { .uname  = "TAKEN_BRANCH_BUFFER_RSRC_STALL",
    .udesc  = "Number of cycles stalled due to taken branch buffer resource stalls",
    .ucode  = 0x10,
  },
  { .uname  = "FP_REG_FILE_RSRC_STALL",
    .udesc  = "Number of cycles stalled due to floating-point register file resource stalls. Applies to all FP ops that have a destination register",
    .ucode  = 0x20,
  },
  { .uname  = "FP_SCHEDULER_RSRC_STALL",
    .udesc  = "Number of cycles stalled due to floating-point scheduler resource stalls. Applies to ops that use the FP scheduler",
    .ucode  = 0x40,
  },
  { .uname  = "FP_FLUSH_RECOVERY_STALL",
    .udesc  = "Number of cycles stalled due to floating-point flush recovery",
    .ucode  = 0x80,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_dispatch_resource_stall_cycles_2[]={
  { .uname  = "INT_SCHEDULER_0_TOKEN_STALL",
    .udesc  = "Number of cycles stalled due to no tokens available for Integer Scheduler Queue 0",
    .ucode  = 0x1,
  },
  { .uname  = "INT_SCHEDULER_1_TOKEN_STALL",
    .udesc  = "Number of cycles stalled due to no tokens available for Integer Scheduler Queue 1",
    .ucode  = 0x2,
  },
  { .uname  = "INT_SCHEDULER_2_TOKEN_STALL",
    .udesc  = "Number of cycles stalled due to no tokens available for Integer Scheduler Queue 2",
    .ucode  = 0x4,
  },
  { .uname  = "INT_SCHEDULER_3_TOKEN_STALL",
    .udesc  = "Number of cycles stalled due to no tokens available for Integer Scheduler Queue 3",
    .ucode  = 0x8,
  },
  { .uname  = "RETIRE_TOKEN_STALL",
    .udesc  = "Number of cycles stalled due to insufficient tokens available for Retire Queue",
    .ucode  = 0x20,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_retired_mmx_fp_instructions[]={
  { .uname  = "SSE_INSTR",
    .udesc  = "Number of SSE instructions (SSE, SSE2, SSE3, SSSE3, SSE4A, SSE41, SSE42, AVX)",
    .ucode  = 0x4,
  },
  { .uname  = "MMX_INSTR",
    .udesc  = "Number of MMX instructions",
    .ucode  = 0x2,
  },
  { .uname  = "X87_INSTR",
    .udesc  = "Number of x87 instructions",
    .ucode  = 0x1,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_tagged_ibs_ops[]={
  { .uname  = "IBS_COUNT_ROLLOVER",
    .udesc  = "Number of times a op could not be tagged by IBS because of a previous tagged op that has not retired",
    .ucode  = 0x4,
  },
  { .uname  = "IBS_TAGGED_OPS_RET",
    .udesc  = "Number of ops tagged by IBS that retired",
    .ucode  = 0x2,
  },
  { .uname  = "IBS_TAGGED_OPS",
    .udesc  = "Number of ops tagged by IBS",
    .ucode  = 0x1,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_requests_to_l2_group1[]={
  { .uname  = "RD_BLK_L",
    .udesc  = "Number of data cache reads (including software and hardware prefetches)",
    .ucode  = 0x80,
  },
  { .uname  = "RD_BLK_X",
    .udesc  = "Number of data cache stores",
    .ucode  = 0x40,
  },
  { .uname  = "LS_RD_BLK_C_S",
    .udesc  = "Number of data cache shared reads",
    .ucode  = 0x20,
  },
  { .uname  = "CACHEABLE_IC_READ",
    .udesc  = "Number of instruction cache reads",
    .ucode  = 0x10,
  },
  { .uname  = "CHANGE_TO_X",
    .udesc  = "Number of requests change to writable, check L2 for current state",
    .ucode  = 0x8,
  },
  { .uname  = "PREFETCH_L2",
    .udesc  = "TBD",
    .ucode  = 0x4,
  },
  { .uname  = "L2_HW_PF",
    .udesc  = "Number of prefetches accepted by L2 pipeline, hit or miss",
    .ucode  = 0x2,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_core_to_l2_cacheable_request_access_status[]={
  { .uname  = "LS_RD_BLK_C_S",
    .udesc  = "Number of data cache shared read hitting in the L2",
    .ucode  = 0x80,
  },
  { .uname  = "LS_RD_BLK_L_HIT_X",
    .udesc  = "Number of data cache reads hitting in the L2",
    .ucode  = 0x40,
  },
  { .uname  = "LS_RD_BLK_L_HIT_S",
    .udesc  = "Number of data cache reads hitting a non-modifiable line in the L2",
    .ucode  = 0x20,
  },
  { .uname  = "LS_RD_BLK_X",
    .udesc  = "Number of data cache store or state change requests hitting in the L2",
    .ucode  = 0x10,
  },
  { .uname  = "LS_RD_BLK_C",
    .udesc  = "Number of data cache requests missing in the L2 (all types)",
    .ucode  = 0x8,
  },
  { .uname  = "IC_FILL_HIT_X",
    .udesc  = "Number of instruction cache fill requests hitting a modifiable line in the L2",
    .ucode  = 0x4,
  },
  { .uname  = "IC_FILL_HIT_S",
    .udesc  = "Number of instruction cache fill requests hitting a non-modifiable line in the L2",
    .ucode  = 0x2,
  },
  { .uname  = "IC_FILL_MISS",
    .udesc  = "Number of instruction cache fill requests missing the L2",
    .ucode  = 0x1,
  },
};

static const amd64_umask_t amd64_fam19h_zen3_l2_prefetch_hit_l2[]={
  { .uname  = "L2_HW_PREFETCHER",
    .udesc  = "Number of requests generated by L2 hardware prefetcher",
    .ucode  = 0x1f,
  },
  { .uname  = "L1_HW_PREFETCHER",
    .udesc  = "Number of requests generated by L1 hardware prefetcher",
    .ucode  = 0xe0,
  },
};

static const amd64_entry_t amd64_fam19h_zen3_pe[]={
  { .name   = "RETIRED_SSE_AVX_FLOPS",
    .desc   = "This is a retire-based event. The number of retired SSE/AVX FLOPS. The number of events logged per cycle can vary from 0 to 64. This event can count above 15 and therefore requires the MergeEvent",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x3,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_retired_sse_avx_flops),
    .umasks = amd64_fam19h_zen3_retired_sse_avx_flops,
  },
  { .name   = "RETIRED_SERIALIZING_OPS",
    .desc   = "The number of serializing Ops retired",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x5,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_retired_serializing_ops),
    .umasks = amd64_fam19h_zen3_retired_serializing_ops,
  },
  { .name   = "FP_DISPATCH_FAULTS",
    .desc   = "Floating-point dispatch faults",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0xe,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_fp_dispatch_faults),
    .umasks = amd64_fam19h_zen3_fp_dispatch_faults,
  },
  { .name   = "BAD_STATUS_2",
    .desc   = "TBD",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x24,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_bad_status_2),
    .umasks = amd64_fam19h_zen3_bad_status_2,
  },
  { .name   = "RETIRED_LOCK_INSTRUCTIONS",
    .desc   = "Counts the number of retired locked instructions",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x25,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_retired_lock_instructions),
    .umasks = amd64_fam19h_zen3_retired_lock_instructions,
  },
  { .name   = "RETIRED_CLFLUSH_INSTRUCTIONS",
    .desc   = "Counts the number of retired non-speculative clflush instructions",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x26,
    .flags   = 0,
  },
  { .name   = "RETIRED_CPUID_INSTRUCTIONS",
    .desc   = "Counts the number of retired cpuid instructions",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x27,
    .flags   = 0,
  },
  { .name   = "LS_DISPATCH",
    .desc   = "Counts the number of operations dispatched to the LS unit. Unit Masks ADDed",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x29,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_ls_dispatch),
    .umasks = amd64_fam19h_zen3_ls_dispatch,
  },
  { .name   = "SMI_RECEIVED",
    .desc   = "Counts the number system management interrupts (SMI) received",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x2b,
    .flags   = 0,
  },
  { .name   = "INTERRUPT_TAKEN",
    .desc   = "Counts the number of interrupts taken",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x2c,
    .flags   = 0,
  },
  { .name   = "STORE_TO_LOAD_FORWARD",
    .desc   = "Number of STore to Load Forward hits",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x35,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "STORE_COMMIT_CANCELS_2",
    .desc   = "TBD",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x37,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_store_commit_cancels_2),
    .umasks = amd64_fam19h_zen3_store_commit_cancels_2,
  },
  { .name   = "MAB_ALLOCATION_BY_TYPE",
    .desc   = "Counts when a LS pipe allocates a MAB entry",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x41,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_mab_allocation_by_type),
    .umasks = amd64_fam19h_zen3_mab_allocation_by_type,
  },
  { .name   = "DEMAND_DATA_CACHE_FILLS_FROM_SYSTEM",
    .desc   = "Demand Data Cache fills by data source",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x43,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_software_prefetch_data_cache_fills),
    .umasks = amd64_fam19h_zen3_software_prefetch_data_cache_fills, /* shared */
  },
  { .name   = "ANY_DATA_CACHE_FILLS_FROM_SYSTEM",
    .desc   = "Any Data Cache fills by data source",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x44,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_software_prefetch_data_cache_fills),
    .umasks = amd64_fam19h_zen3_software_prefetch_data_cache_fills, /* shared */
  },
  { .name   = "L1_DTLB_MISS",
    .desc   = "L1 Data TLB misses",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x45,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_l1_dtlb_miss),
    .umasks = amd64_fam19h_zen3_l1_dtlb_miss,
  },
  { .name   = "MISALIGNED_LOADS",
    .desc   = "Misaligned loads retired",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x47,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_misaligned_loads),
    .umasks = amd64_fam19h_zen3_misaligned_loads,
  },
  { .name   = "PREFETCH_INSTRUCTIONS_DISPATCHED",
    .desc   = "Software Prefetch Instructions Dispatched. This is a speculative event",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x4b,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_prefetch_instructions_dispatched),
    .umasks = amd64_fam19h_zen3_prefetch_instructions_dispatched,
  },
  { .name   = "INEFFECTIVE_SOFTWARE_PREFETCH",
    .desc   = "Number of software prefetches that did not fetch data outside of the processor core",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x52,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_ineffective_software_prefetch),
    .umasks = amd64_fam19h_zen3_ineffective_software_prefetch,
  },
  { .name   = "SOFTWARE_PREFETCH_DATA_CACHE_FILLS",
    .desc   = "Number of software prefetches fills by data source",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x59,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_software_prefetch_data_cache_fills),
    .umasks = amd64_fam19h_zen3_software_prefetch_data_cache_fills, /* shared */
  },
  { .name   = "HARDWARE_PREFETCH_DATA_CACHE_FILLS",
    .desc   = "Number of hardware prefetches fills by data source",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x5a,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_software_prefetch_data_cache_fills),
    .umasks = amd64_fam19h_zen3_software_prefetch_data_cache_fills, /* shared */
  },
  { .name   = "ALLOC_MAB_COUNT",
    .desc   = "Counts the in-flight L1 data cache misses (allocated Miss Address Buffers) divided by 4 and rounded down each cycle unless used with the MergeEvent functionality. If the MergeEvent is used, it counts the exact number of outstanding L1 data cache misses",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x5f,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "CYCLES_NOT_IN_HALT",
    .desc   = "Number of core cycles not in halted state",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x76,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "TLB_FLUSHES",
    .desc   = "Number of TLB flushes",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x78,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_tlb_flushes),
    .umasks = amd64_fam19h_zen3_tlb_flushes,
  },
  { .name   = "INSTRUCTION_CACHE_REFILLS_FROM_L2",
    .desc   = "Number of 64-byte instruction cachelines that was fulfilled by the L2 cache",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x82,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "INSTRUCTION_CACHE_REFILLS_FROM_SYSTEM",
    .desc   = "Number of 64-byte instruction cachelines fulfilled from system memory or another cache",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x83,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "L1_ITLB_MISS_L2_ITLB_HIT",
    .desc   = "Number of instruction fetches that miss in the L1 ITLB but hit in the L2 ITLB",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x84,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "L1_ITLB_MISS_L2_ITLB_MISS",
    .desc   = "The number of valid fills into the ITLB originating from the LS Page-Table Walker. Tablewalk requests are issued for L1-ITLB and L2-ITLB misses",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x85,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_l1_itlb_miss_l2_itlb_miss),
    .umasks = amd64_fam19h_zen3_l1_itlb_miss_l2_itlb_miss,
  },
  { .name   = "L2_BTB_CORRECTION",
    .desc   = "Number of L2 branch prediction overrides of existing prediction. This is a speculative event",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x8b,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "DYNAMIC_INDIRECT_PREDICTIONS",
    .desc   = "Number of times a branch used the indirect predictor to make a prediction",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x8e,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "DECODER_OVERRIDE_BRANCH_PRED",
    .desc   = "Number of decoder overrides of existing branch prediction",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x91,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "L1_ITLB_FETCH_HIT",
    .desc   = "Instruction fetches that hit in the L1 ITLB",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x94,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_itlb_fetch_hit),
    .umasks = amd64_fam19h_zen3_itlb_fetch_hit,
  },
  { .name   = "IC_TAG_HIT_MISS",
    .desc   = "Counts various IC tag related hit and miss events",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x18e,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_ic_tag_hit_miss),
    .umasks = amd64_fam19h_zen3_ic_tag_hit_miss,
  },
  { .name   = "OP_CACHE_HIT_MISS",
    .desc   = "Counts op cache micro-tag hit/miss events",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x28f,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_op_cache_hit_miss),
    .umasks = amd64_fam19h_zen3_op_cache_hit_miss,
  },
  { .name   = "OPS_SOURCE_DISPATCHED_FROM_DECODER",
    .desc   = "Number of ops dispatched from the decoder classified by op source",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0xaa,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_ops_source_dispatched_from_decoder),
    .umasks = amd64_fam19h_zen3_ops_source_dispatched_from_decoder,
  },
  { .name   = "OPS_TYPE_DISPATCHED_FROM_DECODER",
    .desc   = "Number of ops dispatched from the decoder classified by op type",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0xab,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_ops_type_dispatched_from_decoder),
    .umasks = amd64_fam19h_zen3_ops_type_dispatched_from_decoder,
  },
  { .name   = "DISPATCH_RESOURCE_STALL_CYCLES_1",
    .desc   = "Number of cycles where a dispatch group is valid but does not get dispatched due to a Token Stall",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0xae,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_dispatch_resource_stall_cycles_1),
    .umasks = amd64_fam19h_zen3_dispatch_resource_stall_cycles_1,
  },
  { .name   = "DISPATCH_RESOURCE_STALL_CYCLES_2",
    .desc   = "Number of cycles where a dispatch group is valid but does not get dispatched due to a Token Stall",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0xaf,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_dispatch_resource_stall_cycles_2),
    .umasks = amd64_fam19h_zen3_dispatch_resource_stall_cycles_2,
  },
  { .name   = "RETIRED_INSTRUCTIONS",
    .desc   = "Number of instructions retired",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0xc0,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "RETIRED_OPS",
    .desc   = "Number of macro-ops retired",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0xc1,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "RETIRED_BRANCH_INSTRUCTIONS",
    .desc   = "Number of branch instructions retired. This includes all types of architectural control flow changes, including exceptions and interrupts",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0xc2,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "RETIRED_BRANCH_INSTRUCTIONS_MISPREDICTED",
    .desc   = "Number of retired branch instructions, that were mispredicted",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0xc3,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "RETIRED_TAKEN_BRANCH_INSTRUCTIONS",
    .desc   = "Number of taken branches that were retired. This includes all types of architectural control flow changes, including exceptions and interrupts",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0xc4,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "RETIRED_TAKEN_BRANCH_INSTRUCTIONS_MISPREDICTED",
    .desc   = "Number of retired taken branch instructions that were mispredicted",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0xc5,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "RETIRED_FAR_CONTROL_TRANSFERS",
    .desc   = "Number of far control transfers retired including far call/jump/return, IRET, SYSCALL and SYSRET, plus exceptions and interrupts. Far control transfers are not subject to branch prediction",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0xc6,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "RETIRED_NEAR_RETURNS",
    .desc   = "Number of near return instructions (RET or RET Iw) retired",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0xc8,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "RETIRED_NEAR_RETURNS_MISPREDICTED",
    .desc   = "Number of near returns retired that were not correctly predicted by the return address predictor. Each such mispredict incurs the same penalty as a mispredicted conditional branch instruction",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0xc9,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "RETIRED_INDIRECT_BRANCH_INSTRUCTIONS_MISPREDICTED",
    .desc   = "Number of indirect branches retired there were not correctly predicted. Each such mispredict incurs the same penalty as a mispredicted condition branch instruction. Only EX mispredicts are counted",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0xca,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "RETIRED_MMX_FP_INSTRUCTIONS",
    .desc   = "Number of MMX, SSE or x87 instructions retired. The UnitMask allows the selection of the individual classes of instructions as given in the table. Each increment represents one complete instruction. Since this event includes non-numeric instructions, it is not suitable for measuring MFLOPS",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0xcb,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_retired_mmx_fp_instructions),
    .umasks = amd64_fam19h_zen3_retired_mmx_fp_instructions,
  },
  { .name   = "RETIRED_INDIRECT_BRANCH_INSTRUCTIONS",
    .desc   = "Number of indirect branches retired",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0xcc,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "RETIRED_CONDITIONAL_BRANCH_INSTRUCTIONS",
    .desc   = "Number of retired conditional branch instructions",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0xd1,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "DIV_CYCLES_BUSY_COUNT",
    .desc   = "Number of cycles when the divider is busy",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0xd3,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "DIV_OP_COUNT",
    .desc   = "Number of divide ops",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0xd4,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "RETIRED_BRANCH_MISPREDICTED_DIRECTION_MISMATCH",
    .desc   = "Number of retired conditional branch instructions that were not correctly predicted because of branch direction mismatch",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x1c7,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "TAGGED_IBS_OPS",
    .desc   = "Counts Op IBS related events",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x1cf,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_tagged_ibs_ops),
    .umasks = amd64_fam19h_zen3_tagged_ibs_ops,
  },
  { .name   = "RETIRED_FUSED_INSTRUCTIONS",
    .desc   = "Counts retired fused instructions",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x1d0,
    .flags   = 0,
    .ngrp    = 0,
  },
  { .name   = "REQUESTS_TO_L2_GROUP1",
    .desc   = "All L2 cache requests",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x60,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_requests_to_l2_group1),
    .umasks = amd64_fam19h_zen3_requests_to_l2_group1,
  },
  { .name   = "CORE_TO_L2_CACHEABLE_REQUEST_ACCESS_STATUS",
    .desc   = "L2 cache request outcomes. This event does not count accesses to the L2 cache by the L2 prefetcher",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x64,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_core_to_l2_cacheable_request_access_status),
    .umasks = amd64_fam19h_zen3_core_to_l2_cacheable_request_access_status,
  },
  { .name   = "L2_PREFETCH_HIT_L2",
    .desc   = "Number of L2 prefetches that hit in the L2",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x70,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_l2_prefetch_hit_l2),
    .umasks = amd64_fam19h_zen3_l2_prefetch_hit_l2,
  },
  { .name   = "L2_PREFETCH_HIT_L3",
    .desc   = "Number of L2 prefetches accepted by the L2 pipeline which miss the L2 cache and hit the L3",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x71,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_l2_prefetch_hit_l2),
    .umasks = amd64_fam19h_zen3_l2_prefetch_hit_l2,
  },
  { .name   = "L2_PREFETCH_MISS_L3",
    .desc   = "Number of L2 prefetches accepted by the L2 pipeline which miss the L2 and the L3 caches",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0x72,
    .flags   = 0,
    .ngrp    = 1,
    .numasks = LIBPFM_ARRAY_SIZE(amd64_fam19h_zen3_l2_prefetch_hit_l2),
    .umasks = amd64_fam19h_zen3_l2_prefetch_hit_l2,
  },
  { .name   = "UOPS_QUEUE_EMPTY",
    .desc   = "Counts cycles where the decoded uops queue is empty",
    .modmsk  = AMD64_FAM19H_ATTRS,
    .code    = 0xa9,
    .flags   = 0,
    .ngrp    = 0,
  },
};
